<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Package Manager Tools</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f0f2f5;
        }

        .container {
            width: 70%;
            margin: 0 auto;
            padding: 20px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        /* Tab Styles */
        .tabs {
            display: flex;
            margin-bottom: 20px;
            border-bottom: 2px solid #e1e4e8;
        }

        .tab {
            padding: 10px 20px;
            cursor: pointer;
            border: none;
            background: none;
            font-size: 16px;
            color: #586069;
            position: relative;
        }

        .tab.active {
            color: #2196F3;
            font-weight: bold;
        }

        .tab.active::after {
            content: '';
            position: absolute;
            bottom: -2px;
            left: 0;
            width: 100%;
            height: 2px;
            background-color: #2196F3;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .section {
            margin: 15px 0;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 4px;
            border: 1px solid #e1e4e8;
            flex: 1;
        }

        button {
            padding: 8px 16px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        button:hover {
            background: #0056b3;
        }

        button:disabled {
            background: #ccc;
        }

        .toggle {
            position: relative;
            display: inline-block;
            width: 60px;
            height: 34px;
            margin-left: 10px;
        }

        .toggle input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 34px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 26px;
            width: 26px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked + .slider {
            background-color: #2196F3;
        }

        input:checked + .slider:before {
            transform: translateX(26px);
        }

        .result {
            margin-top: 10px;
            padding: 10px;
            border-radius: 4px;
            background: white;
        }

        .error { color: red; }
        .success { color: green; }

        /* Log Section Styles */
        .log-container {
            height: 300px;
            overflow-y: auto;
            background: #1e1e1e;
            color: #fff;
            padding: 15px;
            border-radius: 4px;
            font-family: monospace;
            margin-bottom: 10px;
        }

        .log-entry {
            margin: 5px 0;
            padding: 5px;
            border-bottom: 1px solid #333;
            display: flex;
            align-items: center;
        }

        .log-entry.success { color: #28a745; }
        .log-entry.error { color: #dc3545; }
        .log-entry.warning { color: #ffc107; }
        .log-entry.info { color: #17a2b8; }
        .log-entry.debug { color: #6c757d; }
        .log-entry.request { color: #9c27b0; }
        .log-entry.response { color: #4caf50; }

        .log-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }

        .log-btn {
            padding: 8px 16px;
            background: #6c757d;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .log-btn:hover {
            background: #5a6268;
        }

        .log-btn i {
            font-size: 16px;
        }

        /* Add this to your existing styles */
        .manager-container {
            display: flex;
            gap: 20px;
            justify-content: space-between;
        }

        .package-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 20px;
            padding: 10px;
        }

        .package-card {
            background: white;
            border: 1px solid #e1e4e8;
            border-radius: 6px;
            padding: 15px;
            position: relative;
        }

        .package-card h4 {
            margin: 0 0 10px 0;
            color: #24292e;
        }

        .package-desc {
            color: #586069;
            font-size: 14px;
            margin-bottom: 15px;
        }

        .package-status {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-top: 10px;
            border-top: 1px solid #e1e4e8;
        }

        .package-controls {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .refresh-btn {
            padding: 4px 8px;
            background: #6c757d;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .refresh-btn:hover {
            background: #5a6268;
        }

        .refresh-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .refresh-icon {
            display: inline-block;
            transition: transform 0.3s ease;
        }

        .refresh-btn:active .refresh-icon {
            transform: rotate(180deg);
        }

        .status-badge {
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: 500;
        }

        .installed {
            background-color: #28a745;
            color: white;
        }

        .not-installed {
            background-color: #dc3545;
            color: white;
        }

        .version {
            color: #586069;
            font-size: 12px;
        }

        .package-toggle {
            width: 50px;
            height: 26px;
            margin: 0;
        }

        .package-toggle .slider {
            height: 26px;
        }

        .package-toggle .slider:before {
            height: 20px;
            width: 20px;
            left: 3px;
            bottom: 3px;
        }

        .package-toggle input:checked + .slider:before {
            transform: translateX(24px);
        }

        .status-info {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .status-controls {
            margin-bottom: 20px;
            display: flex;
            justify-content: flex-end;
        }

        .bulk-check-btn {
            padding: 8px 16px;
            background: #2196F3;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
            transition: background-color 0.2s;
        }

        .bulk-check-btn:hover {
            background: #1976D2;
        }

        .bulk-check-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .bulk-check-btn .refresh-icon {
            display: inline-block;
            transition: transform 0.3s ease;
        }

        .bulk-check-btn:disabled .refresh-icon {
            animation: spin 1s linear infinite;
        }

        .bulk-refresh-btn {
            padding: 8px 16px;
            background: #2196F3;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
            transition: background-color 0.2s;
        }

        .bulk-refresh-btn:hover {
            background: #1976D2;
        }

        .bulk-refresh-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .bulk-refresh-btn .refresh-icon {
            display: inline-block;
            transition: transform 0.3s ease;
        }

        .bulk-refresh-btn:disabled .refresh-icon {
            animation: spin 1s linear infinite;
        }

        .stop-btn {
            padding: 4px 8px;
            background: #dc3545;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0 5px;
        }

        .stop-btn:hover {
            background: #c82333;
        }

        .stop-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .stop-icon {
            font-size: 12px;
        }

        /* Progress Bar Styles */
        .progress-container {
            margin-top: 10px;
            width: 100%;
            display: none;
        }

        .progress-bar {
            width: 100%;
            height: 4px;
            background-color: #f0f0f0;
            border-radius: 2px;
            overflow: hidden;
        }

        .progress-bar-fill {
            height: 100%;
            background-color: #2196F3;
            width: 0;
            transition: width 0.3s ease;
        }

        .progress-text {
            font-size: 12px;
            color: #666;
            margin-top: 4px;
            text-align: center;
        }

        .bulk-progress {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-left: 10px;
        }

        .bulk-progress .progress-bar {
            width: 150px;
        }

        .package-progress {
            margin-top: 10px;
        }

        .package-progress .progress-container {
            margin-top: 5px;
        }

        /* Add this to your existing styles */
        .status-controls {
            display: flex;
            align-items: center;
        }

        /* Progress Bar Styles */
        .bulk-status-container {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
        }

        .progress-container {
            display: none;
            width: 100%;
            margin-top: 8px;
        }

        .progress-bar {
            width: 100%;
            height: 4px;
            background-color: #f0f0f0;
            border-radius: 2px;
            overflow: hidden;
        }

        .progress-bar-fill {
            height: 100%;
            background-color: #2196F3;
            width: 0;
            transition: width 0.3s ease;
        }

        .progress-text {
            font-size: 12px;
            color: #666;
            margin-top: 4px;
            text-align: center;
        }

        .bulk-progress {
            flex: 1;
            max-width: 300px;
        }

        .bulk-progress .progress-container {
            margin-top: 0;
        }

        .package-progress {
            margin-top: 10px;
        }

        /* Animation for progress bars */
        @keyframes progress-pulse {
            0% { opacity: 0.6; }
            50% { opacity: 1; }
            100% { opacity: 0.6; }
        }

        .progress-bar-fill.indeterminate {
            animation: progress-pulse 1.5s infinite;
            width: 100%;
            background: linear-gradient(90deg, #2196F3 0%, #64B5F6 50%, #2196F3 100%);
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="tabs">
            <button class="tab active" onclick="openTab('managers')">Package Managers</button>
            <button class="tab" onclick="openTab('winget-status')">Winget Package Status</button>
            <button class="tab" onclick="openTab('choco-status')">Chocolatey Package Status</button>
            <button class="tab" onclick="openTab('logs')">Logs</button>
        </div>

        <div id="managers" class="tab-content active">
            <div class="manager-container">
                <div class="section">
                    <h3>Winget</h3>
                    <button id="checkWinget">Check Version</button>
                    <div id="wingetResult" class="result"></div>
                </div>

                <div class="section" id="chocoSection">
                    <h3>Chocolatey</h3>
                    <button id="checkChoco">Check Version</button>
                    <label class="toggle">
                        <input type="checkbox" id="chocoToggle">
                        <span class="slider"></span>
                    </label>
                    <div id="chocoResult" class="result"></div>
                </div>
            </div>
        </div>

        <div id="winget-status" class="tab-content">
            <div class="section">
                <div class="status-controls">
                    <div class="bulk-status-container">
                        <button class="bulk-refresh-btn" onclick="forceWingetBulkStatusCheck()">
                            <span class="refresh-icon">↻</span> Refresh All
                        </button>
                        <div class="bulk-progress">
                            <div class="progress-container">
                                <div class="progress-bar">
                                    <div class="progress-bar-fill"></div>
                                </div>
                                <div class="progress-text"></div>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="package-grid" id="winget-package-grid">
                    <!-- Winget Packages will be loaded here -->
                </div>
            </div>
        </div>

        <div id="choco-status" class="tab-content">
            <div class="section">
                <div class="status-controls">
                    <div class="bulk-status-container">
                        <button class="bulk-refresh-btn" onclick="forceChocoBulkStatusCheck()">
                            <span class="refresh-icon">↻</span> Refresh All
                        </button>
                        <div class="bulk-progress">
                            <div class="progress-container">
                                <div class="progress-bar">
                                    <div class="progress-bar-fill"></div>
                                </div>
                                <div class="progress-text"></div>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="package-grid" id="choco-package-grid">
                    <!-- Chocolatey Packages will be loaded here -->
                </div>
            </div>
        </div>

        <div id="logs" class="tab-content">
            <div class="log-controls">
                <button class="log-btn" onclick="copyLogs()">
                    <i>📋</i> Copy Logs
                </button>
                <button class="log-btn" onclick="downloadLogs()">
                    <i>⬇️</i> Download Logs
                </button>
                <button class="log-btn" onclick="clearLogs()">
                    <i>🗑️</i> Clear Logs
                </button>
            </div>
            <div class="log-container" id="logContainer">
                <!-- Logs will be populated here -->
            </div>
        </div>
    </div>

    <script>
        // Configuration constants
        const CONFIG = {
            POLL_INTERVAL: 15000,        // 15 seconds between status checks
            MIN_BACKOFF: 5000,           // Minimum backoff time (5 seconds)
            MAX_BACKOFF: 30000,          // Maximum backoff time (30 seconds)
            MAX_RETRIES: 20,             // Maximum number of retry attempts
            QUEUE_CHECK_INTERVAL: 1000    // Queue processing interval (1 second)
        };

        // Operation queue system
        const operationQueue = {
            winget: new Map(),
            choco: new Map(),
            pendingOperations: [],
            isProcessing: false,
            
            isOperationInProgress: function(manager, appId) {
                return this[manager].has(appId);
            },
            
            addOperation: function(manager, appId, operation) {
                if (this.isOperationInProgress(manager, appId)) {
                    return Promise.reject(new Error('Operation already in progress'));
                }
                
                const promise = new Promise((resolve, reject) => {
                    this.pendingOperations.push({
                        manager,
                        appId,
                        operation,
                        resolve,
                        reject,
                        retryCount: 0,
                        nextRetryDelay: CONFIG.MIN_BACKOFF,
                        isStopped: false
                    });
                });
                
                this[manager].set(appId, promise);
                this.processQueue();
                return promise;
            },
            
            stopOperation: function(manager, appId) {
                const pendingOp = this.pendingOperations.find(op => 
                    op.manager === manager && op.appId === appId
                );
                
                if (pendingOp) {
                    pendingOp.isStopped = true;
                    this.pendingOperations = this.pendingOperations.filter(op => 
                        !(op.manager === manager && op.appId === appId)
                    );
                    this[manager].delete(appId);
                    pendingOp.reject(new Error('Operation stopped by user'));
                    return true;
                }
                return false;
            },
            
            processQueue: async function() {
                if (this.isProcessing || this.pendingOperations.length === 0) return;
                
                this.isProcessing = true;
                const op = this.pendingOperations.shift();
                
                try {
                    if (!op.isStopped) {
                    const result = await op.operation();
                    this[op.manager].delete(op.appId);
                    op.resolve(result);
                    }
                } catch (error) {
                    if (!op.isStopped && op.retryCount < CONFIG.MAX_RETRIES) {
                        op.retryCount++;
                        op.nextRetryDelay = Math.min(
                            op.nextRetryDelay * 2,
                            CONFIG.MAX_BACKOFF
                        );
                        setTimeout(() => {
                            this.pendingOperations.push(op);
                        }, op.nextRetryDelay);
                    } else {
                        this[op.manager].delete(op.appId);
                        op.reject(error);
                    }
                }
                
                this.isProcessing = false;
                setTimeout(() => this.processQueue(), CONFIG.QUEUE_CHECK_INTERVAL);
            }
        };

        // Global state to track package initialization
        let hasInitializedWingetPackages = false;
        let hasInitializedChocoPackages = false;

        /**
         * Tab Management
         * Handles switching between different tabs and initializes package loading
         * @param {string} tabName - Name of the tab to open
         */
        function openTab(tabName) {
            addLogEntry(`Switching to ${tabName} tab`, 'INFO');

            // Hide all tab contents
            const tabContents = document.getElementsByClassName('tab-content');
            for (let content of tabContents) {
                content.classList.remove('active');
            }

            // Remove active class from all tabs
            const tabs = document.getElementsByClassName('tab');
            for (let tab of tabs) {
                tab.classList.remove('active');
            }

            // Show the selected tab content
            document.getElementById(tabName).classList.add('active');
            // Add active class to the clicked tab
            event.currentTarget.classList.add('active');

            // Load packages based on tab
            if (tabName === 'winget-status' && !hasInitializedWingetPackages) {
                addLogEntry('First time opening Winget Status tab - initializing package list', 'INFO');
                loadWingetPackages();
                hasInitializedWingetPackages = true;
            } else if (tabName === 'choco-status' && !hasInitializedChocoPackages) {
                addLogEntry('First time opening Chocolatey Status tab - initializing package list', 'INFO');
                loadChocoPackages();
                hasInitializedChocoPackages = true;
            }
        }

        /**
         * Log Entry Management
         * Adds a new log entry to the log container with timestamp and styling
         * @param {string} message - The log message to display
         * @param {string} type - The type of log (INFO, DEBUG, SUCCESS, WARNING, ERROR, REQUEST, RESPONSE)
         */
        function addLogEntry(message, type) {
            const logContainer = document.getElementById('logContainer');
            const logEntry = document.createElement('div');
            logEntry.className = `log-entry ${type.toLowerCase()}`;
            
            // Add timestamp
            const timestamp = new Date().toLocaleTimeString();
            logEntry.textContent = `[${timestamp}] ${message}`;
            
            logContainer.appendChild(logEntry);
            logContainer.scrollTop = logContainer.scrollHeight;

            // Send log to server for persistence
            fetch('http://localhost:9000/api/log', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    message: message,
                    type: type,
                    source: 'GUI'
                })
            }).catch(err => console.error('Failed to send log to server:', err));
        }

        /**
         * Log Management Functions
         * Handle copying, downloading, and clearing of logs
         */
        function copyLogs() {
            addLogEntry('Copying logs to clipboard', 'INFO');
            const logContainer = document.getElementById('logContainer');
            const logText = Array.from(logContainer.children)
                .map(entry => entry.textContent)
                .join('\n');
            
            navigator.clipboard.writeText(logText).then(() => {
                addLogEntry('Logs copied successfully', 'SUCCESS');
            }).catch(err => {
                addLogEntry(`Failed to copy logs: ${err.message}`, 'ERROR');
            });
        }

        function downloadLogs() {
            addLogEntry('Preparing logs for download', 'INFO');
            const logContainer = document.getElementById('logContainer');
            const logText = Array.from(logContainer.children)
                .map(entry => entry.textContent)
                .join('\n');
            
            const blob = new Blob([logText], { type: 'text/plain' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            
            const timestamp = new Date().toISOString().slice(0,19).replace(/[:]/g, '-');
            a.href = url;
            a.download = `logs_${timestamp}.txt`;
            document.body.appendChild(a);
            a.click();
            
            window.URL.revokeObjectURL(url);
            document.body.removeChild(a);
            addLogEntry('Logs downloaded successfully', 'SUCCESS');
        }

        function clearLogs() {
            if (confirm('Are you sure you want to clear all logs?')) {
                const logContainer = document.getElementById('logContainer');
                logContainer.innerHTML = '';
                addLogEntry('Log history cleared', 'INFO');
            }
        }

        // Initialize UI elements
        const wingetBtn = document.getElementById('checkWinget');
        const chocoBtn = document.getElementById('checkChoco');
        const chocoToggle = document.getElementById('chocoToggle');

        /**
         * Winget Version Check
         * Queries the server for Winget version and updates UI accordingly
         */
        async function checkWinget() {
            const result = document.getElementById('wingetResult');
            wingetBtn.disabled = true;
            addLogEntry('Checking Winget version...', 'INFO');
            
            try {
                const response = await fetch('http://localhost:9000/api/winget-version');
                const data = await response.json();
                
                if (data.version && !data.version.includes('Error')) {
                    result.textContent = `Version: ${data.version}`;
                    result.className = 'result success';
                    addLogEntry(`Winget version check successful: ${data.version}`, 'SUCCESS');
                } else {
                    result.textContent = 'Winget not installed';
                    result.className = 'result error';
                    addLogEntry('Winget not installed', 'ERROR');
                }
            } catch (error) {
                result.textContent = 'Error checking version';
                result.className = 'result error';
                addLogEntry(`Error checking Winget version: ${error.message}`, 'ERROR');
            }
            wingetBtn.disabled = false;
        }

        /**
         * Chocolatey Version Check
         * Queries the server for Chocolatey version and updates UI accordingly
         */
        async function checkChoco() {
            const result = document.getElementById('chocoResult');
            chocoBtn.disabled = true;
            addLogEntry('Checking Chocolatey version...', 'INFO');
            
            try {
                const response = await fetch('http://localhost:9000/api/choco-version');
                const data = await response.json();
                
                if (data.version.installed) {
                    result.textContent = `Version: ${data.version.version}`;
                    result.className = 'result success';
                    chocoToggle.checked = true;
                    addLogEntry(`Chocolatey version check successful: ${data.version.version}`, 'SUCCESS');
                } else {
                    result.textContent = 'Chocolatey is not installed';
                    result.className = 'result error';
                    chocoToggle.checked = false;
                    addLogEntry('Chocolatey is not installed', 'WARNING');
                }
            } catch (error) {
                result.textContent = 'Error checking version';
                result.className = 'result error';
                addLogEntry(`Error checking Chocolatey version: ${error.message}`, 'ERROR');
            }
            chocoBtn.disabled = false;
        }

        /**
         * Chocolatey Installation Toggle Handler
         * Manages installation/uninstallation of Chocolatey based on toggle state
         */
        chocoToggle.addEventListener('change', async () => {
            const result = document.getElementById('chocoResult');
            const endpoint = chocoToggle.checked ? 'install' : 'uninstall';
            const action = chocoToggle.checked ? 'Installing' : 'Uninstalling';
            
            result.textContent = `${action}...`;
            result.className = 'result';
            addLogEntry(`${action} Chocolatey...`, 'INFO');
            
            try {
                // Perform installation/uninstallation
                const response = await fetch(`http://localhost:9000/api/choco-${endpoint}`);
                const data = await response.json();
                
                // Wait for operation to complete
                await new Promise(resolve => setTimeout(resolve, 2000));
                
                // Verify installation status
                const verifyResponse = await fetch('http://localhost:9000/api/choco-version');
                const verifyData = await verifyResponse.json();
                
                const isInstalled = verifyData.version.installed;
                const shouldBeInstalled = endpoint === 'install';
                
                if (isInstalled === shouldBeInstalled) {
                    await checkChoco(); // Updates UI and logs success
                } else {
                    result.textContent = `${endpoint} failed`;
                    result.className = 'result error';
                    chocoToggle.checked = !chocoToggle.checked;
                    addLogEntry(`Chocolatey ${endpoint} failed - verification failed`, 'ERROR');
                }
            } catch (error) {
                result.textContent = `${endpoint} failed`;
                result.className = 'result error';
                chocoToggle.checked = !chocoToggle.checked;
                addLogEntry(`Error during Chocolatey ${endpoint}: ${error.message}`, 'ERROR');
            }
        });

        // Event Listeners for version check buttons
        wingetBtn.addEventListener('click', checkWinget);
        chocoBtn.addEventListener('click', checkChoco);

        /**
         * Package Management Functions
         * Handle loading, displaying, and managing package status
         */

        /**
         * Loads and displays all Winget packages
         * Creates cards for each package with status, version, and controls
         */
        async function loadWingetPackages() {
            const packageGrid = document.getElementById('winget-package-grid');
            packageGrid.innerHTML = 'Loading packages...';
            addLogEntry('Loading Winget package list...', 'INFO');

            try {
                // Check for cached package data
                const cachedData = sessionStorage.getItem('wingetPackageData');
                if (cachedData) {
                    addLogEntry('Using cached Winget package data', 'INFO');
                    displayWingetPackages(JSON.parse(cachedData));
                    return;
                }

                // Fetch package list from server
                const response = await fetch('http://localhost:9000/api/winget/packages-list');
                const data = await response.json();

                if (data.success) {
                    sessionStorage.setItem('wingetPackageData', JSON.stringify(data));
                    addLogEntry(`Successfully loaded ${data.packages.length} Winget packages`, 'SUCCESS');
                    displayWingetPackages(data);
                } else {
                    packageGrid.innerHTML = 'Error loading Winget packages list';
                    addLogEntry('Failed to load Winget packages list', 'ERROR');
                }
            } catch (error) {
                packageGrid.innerHTML = 'Error loading Winget packages list';
                addLogEntry(`Error loading Winget packages: ${error.message}`, 'ERROR');
            }
        }

        /**
         * Displays Winget packages and their status
         * @param {Object} data - Package data to display
         */
        async function displayWingetPackages(data) {
            const packageGrid = document.getElementById('winget-package-grid');
            packageGrid.innerHTML = '';
            addLogEntry('Rendering Winget package cards...', 'DEBUG');
            
            for (const pkg of data.packages) {
                const card = document.createElement('div');
                card.className = 'package-card';
                card.setAttribute('data-app-id', pkg.app_id);  // Add data-app-id attribute
                
                card.innerHTML = `
                    <h4>${pkg.app_name}</h4>
                    <div class="package-desc">${pkg.app_desc}</div>
                    <div class="package-status">
                        <div class="status-info">
                            <span class="status-badge">Checking...</span>
                            <span class="version"></span>
                        </div>
                        <div class="package-controls">
                            <button class="refresh-btn" onclick="refreshWingetPackage('${pkg.app_id}', this)">
                                <span class="refresh-icon">↻</span>
                            </button>
                            <button class="stop-btn" onclick="stopPackageOperation('winget', '${pkg.app_id}', this)" style="display: none;">
                                <span class="stop-icon">⬛</span>
                            </button>
                            <label class="toggle package-toggle">
                                <input type="checkbox" data-app-id="${pkg.app_id}">
                                <span class="slider"></span>
                            </label>
                        </div>
                    </div>
                    <div class="package-progress">
                        <div class="progress-container">
                            <div class="progress-bar">
                                <div class="progress-bar-fill"></div>
                            </div>
                            <div class="progress-text"></div>
                        </div>
                    </div>
                `;
                
                packageGrid.appendChild(card);
                
                const toggle = card.querySelector('input[type="checkbox"]');
                toggle.addEventListener('change', () => handleWingetPackageToggle(pkg.app_id, toggle));
            }

            // Check for cached status data
            const cachedStatus = sessionStorage.getItem('wingetPackageStatus');
            if (cachedStatus) {
                addLogEntry('Using cached Winget package status data', 'INFO');
                updateWingetPackageStatusFromCache(JSON.parse(cachedStatus));
            } else {
                // Only perform bulk status check once
                await performWingetBulkStatusCheck();
            }
        }

        /**
         * Updates Winget package status from cached data
         * @param {Object} statusData - Cached status data
         */
        function updateWingetPackageStatusFromCache(statusData) {
            addLogEntry('Updating Winget package status from cache...', 'DEBUG');
            const packageCards = document.querySelectorAll('#winget-package-grid .package-card');
            
            packageCards.forEach(card => {
                const appId = card.querySelector('input[type="checkbox"]').dataset.appId;
                const status = statusData[appId];
                
                if (status) {
                    const statusBadge = card.querySelector('.status-badge');
                    const versionSpan = card.querySelector('.version');
                    const toggle = card.querySelector('input[type="checkbox"]');
                    
                    if (status.installed) {
                        statusBadge.textContent = 'Installed';
                        statusBadge.className = 'status-badge installed';
                        versionSpan.textContent = status.version || '';
                        toggle.checked = true;
                        addLogEntry(`Winget package ${appId} is installed (version ${status.version || 'unknown'})`, 'SUCCESS');
                    } else {
                        statusBadge.textContent = 'Not Installed';
                        statusBadge.className = 'status-badge not-installed';
                        versionSpan.textContent = '';
                        toggle.checked = false;
                        addLogEntry(`Winget package ${appId} is not installed`, 'INFO');
                    }
                }
            });
            addLogEntry('Winget package status updated from cache', 'SUCCESS');
        }

        /**
         * Progress Bar Management Functions
         */
        function showProgress(container, text = '') {
            const progressContainer = container.querySelector('.progress-container');
            const progressText = container.querySelector('.progress-text');
            const progressBarFill = container.querySelector('.progress-bar-fill');
            
            progressContainer.style.display = 'block';
            progressText.textContent = text;
            progressBarFill.style.width = '0%';
            progressBarFill.classList.remove('indeterminate');
        }

        function updateProgress(container, progress, text = '') {
            const progressBarFill = container.querySelector('.progress-bar-fill');
            const progressText = container.querySelector('.progress-text');
            
            if (progress === -1) {
                progressBarFill.classList.add('indeterminate');
            } else {
                progressBarFill.classList.remove('indeterminate');
                progressBarFill.style.width = `${progress}%`;
            }
            
            if (text) {
                progressText.textContent = text;
            }
        }

        function hideProgress(container) {
            const progressContainer = container.querySelector('.progress-container');
            progressContainer.style.display = 'none';
        }

        /**
         * Updated Winget Bulk Status Check
         */
        async function performWingetBulkStatusCheck() {
            const packageCards = document.querySelectorAll('#winget-package-grid .package-card');
            const bulkProgressContainer = document.querySelector('#winget-status .bulk-progress');
            const bulkRefreshBtn = document.querySelector('#winget-status .bulk-refresh-btn');
            const totalPackages = packageCards.length;
            let completedPackages = 0;
            
            showProgress(bulkProgressContainer, 'Starting bulk check...');
            bulkRefreshBtn.disabled = true;
            
            packageCards.forEach(card => {
                const statusBadge = card.querySelector('.status-badge');
                const toggle = card.querySelector('input[type="checkbox"]');
                if (statusBadge) {
                    statusBadge.textContent = 'Checking...';
                    statusBadge.className = 'status-badge pending';
                }
                if (toggle) {
                    toggle.disabled = true;
                }
            });
            
            try {
                addLogEntry('Starting Winget bulk status check...', 'DEBUG');
                
                // Create a status cache object
                const statusCache = {};
                
                // Function to update a single package's status
                function updatePackageStatus(result) {
                    completedPackages++;
                    const progress = (completedPackages / totalPackages) * 100;
                    
                    const card = document.querySelector(`#winget-package-grid .package-card[data-app-id="${result.appId}"]`);
                    if (card) {
                        const statusBadge = card.querySelector('.status-badge');
                        const versionSpan = card.querySelector('.version');
                        const toggle = card.querySelector('input[type="checkbox"]');
                        
                        if (result.status.installed) {
                            statusBadge.textContent = 'Installed';
                            statusBadge.className = 'status-badge installed';
                            versionSpan.textContent = result.status.version || '';
                            toggle.checked = true;
                            addLogEntry(`Winget package ${result.appId} is installed (version ${result.status.version || 'unknown'})`, 'SUCCESS');
                        } else {
                            statusBadge.textContent = 'Not Installed';
                            statusBadge.className = 'status-badge not-installed';
                            versionSpan.textContent = '';
                            toggle.checked = false;
                            addLogEntry(`Winget package ${result.appId} is not installed`, 'INFO');
                        }
                        toggle.disabled = false;
                        
                        // Cache the status
                        statusCache[result.appId] = result.status;
                    }
                    
                    // Update progress bar
                    if (completedPackages >= totalPackages) {
                        // All packages processed - show completion
                        updateProgress(bulkProgressContainer, 100, 'Status check complete');
                        setTimeout(() => {
                            hideProgress(bulkProgressContainer);
                            bulkRefreshBtn.disabled = false;
                        }, 1000);
                        
                        // Store the status cache in sessionStorage
                        sessionStorage.setItem('wingetPackageStatus', JSON.stringify(statusCache));
                        addLogEntry('Winget bulk status check completed successfully', 'SUCCESS');
                    } else {
                        // Still processing - show current package
                        updateProgress(bulkProgressContainer, progress, `Checking packages (${completedPackages}/${totalPackages})...`);
                    }
                }
                
                // Process each package one by one
                for (const card of packageCards) {
                    const appId = card.getAttribute('data-app-id');
                    try {
                        const response = await fetch('http://localhost:9000/api/winget/bulk-status', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ appId })
                        });

                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }

                        const data = await response.json();
                        if (!data.success) {
                            throw new Error(data.error || 'Failed to get status');
                        }

                        // Update the UI for this package
                        if (data.results && data.results.length > 0) {
                            updatePackageStatus(data.results[0]);
                        }
                    } catch (error) {
                        addLogEntry(`Error checking status for ${appId}: ${error.message}`, 'ERROR');
                        const statusBadge = card.querySelector('.status-badge');
                        const toggle = card.querySelector('input[type="checkbox"]');
                        statusBadge.textContent = 'Error';
                        statusBadge.className = 'status-badge not-installed';
                        toggle.disabled = false;
                        
                        // Update progress even for failed checks
                        completedPackages++;
                        const progress = (completedPackages / totalPackages) * 100;
                        updateProgress(bulkProgressContainer, progress, `Error checking ${appId}`);
                        
                        // Check if this was the last package
                        if (completedPackages >= totalPackages) {
                            setTimeout(() => {
                                hideProgress(bulkProgressContainer);
                                bulkRefreshBtn.disabled = false;
                            }, 1000);
                        }
                    }
                }
                
            } catch (error) {
                updateProgress(bulkProgressContainer, 100, 'Error during bulk check');
                setTimeout(() => {
                    hideProgress(bulkProgressContainer);
                    bulkRefreshBtn.disabled = false;
                }, 2000);
                
                packageCards.forEach(card => {
                    const statusBadge = card.querySelector('.status-badge');
                    const toggle = card.querySelector('input[type="checkbox"]');
                    statusBadge.textContent = 'Error';
                    statusBadge.className = 'status-badge not-installed';
                    toggle.disabled = false;
                });
                
                addLogEntry(`Error during Winget bulk status check: ${error.message}`, 'ERROR');
            }
        }

        /**
         * Updated Winget Package Toggle Handler
         */
        async function handleWingetPackageToggle(appId, toggle) {
            const card = toggle.closest('.package-card');
            const progressContainer = card.querySelector('.package-progress');
            const action = toggle.checked ? 'install' : 'uninstall';
            
            showProgress(progressContainer, `Starting ${action}...`);
            updateProgress(progressContainer, -1); // Show indeterminate progress
            
            try {
                const response = await fetch(`http://localhost:9000/api/winget/${action}-package`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ appId })
                });
                
                const data = await response.json();
                if (!data.success) {
                    throw new Error(data.error || `Failed to ${action} package`);
                }
                
                updateProgress(progressContainer, 100, 'Complete!');
                setTimeout(() => {
                    hideProgress(progressContainer);
                }, 1000);
                
            } catch (error) {
                updateProgress(progressContainer, 100, 'Error!');
                setTimeout(() => {
                    hideProgress(progressContainer);
                }, 2000);
                toggle.checked = !toggle.checked;
            }
        }

        /**
         * Refreshes the status of a single Winget package
         * @param {string} appId - The package identifier
         * @param {HTMLElement} button - The refresh button element
         */
        async function refreshWingetPackage(appId, button) {
            const card = button.closest('.package-card');
            const statusBadge = card.querySelector('.status-badge');
            const refreshIcon = button.querySelector('.refresh-icon');
            
            addLogEntry(`Refreshing status for Winget package ${appId}...`, 'INFO');
            button.disabled = true;
            statusBadge.textContent = 'Checking...';
            refreshIcon.style.transform = 'rotate(360deg)';
            
            try {
                const response = await fetch('http://localhost:9000/api/winget/single-package-status', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ appId, refresh: true })
                });
                
                const data = await response.json();
                const versionSpan = card.querySelector('.version');
                const toggle = card.querySelector('input[type="checkbox"]');
                
                if (data.status.installed) {
                    statusBadge.textContent = 'Installed';
                    statusBadge.className = 'status-badge installed';
                    versionSpan.textContent = data.status.version || '';
                    toggle.checked = true;
                    addLogEntry(`Winget package ${appId} is installed (version ${data.status.version || 'unknown'})`, 'SUCCESS');
                } else {
                    statusBadge.textContent = 'Not Installed';
                    statusBadge.className = 'status-badge not-installed';
                    versionSpan.textContent = '';
                    toggle.checked = false;
                    addLogEntry(`Winget package ${appId} is not installed`, 'INFO');
                }
            } catch (error) {
                statusBadge.textContent = 'Error';
                statusBadge.className = 'status-badge not-installed';
                addLogEntry(`Error refreshing Winget package status for ${appId}: ${error.message}`, 'ERROR');
            } finally {
                button.disabled = false;
                refreshIcon.style.transform = 'rotate(0deg)';
            }
        }

        /**
         * Stops a package operation and updates UI
         * @param {string} manager - The package manager (winget/choco)
         * @param {string} appId - The package identifier
         * @param {HTMLElement} button - The stop button element
         */
        async function stopPackageOperation(manager, appId, button) {
            const card = button.closest('.package-card');
                    const statusBadge = card.querySelector('.status-badge');
            const toggle = card.querySelector('input[type="checkbox"]');
            const stopBtn = card.querySelector('.stop-btn');
            
            addLogEntry(`Stopping ${manager} operation for package ${appId}...`, 'INFO');
            
            if (operationQueue.stopOperation(manager, appId)) {
                statusBadge.textContent = 'Operation Stopped';
                toggle.checked = !toggle.checked;
                toggle.disabled = false;
                stopBtn.style.display = 'none';
                addLogEntry(`Successfully stopped ${manager} operation for package ${appId}`, 'SUCCESS');
            }
        }

        /**
         * Loads and displays all Chocolatey packages
         * Creates cards for each package with status, version, and controls
         */
        async function loadChocoPackages() {
            const packageGrid = document.getElementById('choco-package-grid');
            packageGrid.innerHTML = 'Loading packages...';
            addLogEntry('Loading Chocolatey package list...', 'INFO');

            try {
                // Check for cached package data
                const cachedData = sessionStorage.getItem('chocoPackageData');
                if (cachedData) {
                    addLogEntry('Using cached Chocolatey package data', 'INFO');
                    displayChocoPackages(JSON.parse(cachedData));
                    return;
                }

                // Fetch package list from server
                const response = await fetch('http://localhost:9000/api/choco/packages-list');
                const data = await response.json();

                if (data.success) {
                    sessionStorage.setItem('chocoPackageData', JSON.stringify(data));
                    addLogEntry(`Successfully loaded ${data.packages.length} Chocolatey packages`, 'SUCCESS');
                    displayChocoPackages(data);
                } else {
                    packageGrid.innerHTML = 'Error loading Chocolatey packages list';
                    addLogEntry('Failed to load Chocolatey packages list', 'ERROR');
                }
            } catch (error) {
                packageGrid.innerHTML = 'Error loading Chocolatey packages list';
                addLogEntry(`Error loading Chocolatey packages: ${error.message}`, 'ERROR');
            }
        }

        /**
         * Displays Chocolatey packages and their status
         * @param {Object} data - Package data to display
         */
        async function displayChocoPackages(data) {
            const packageGrid = document.getElementById('choco-package-grid');
            packageGrid.innerHTML = '';
            addLogEntry('Rendering Chocolatey package cards...', 'DEBUG');
            
            for (const pkg of data.packages) {
                const card = document.createElement('div');
                card.className = 'package-card';
                
                card.innerHTML = `
                    <h4>${pkg.app_name}</h4>
                    <div class="package-desc">${pkg.app_desc}</div>
                    <div class="package-status">
                        <div class="status-info">
                            <span class="status-badge">Checking...</span>
                            <span class="version"></span>
                        </div>
                        <div class="package-controls">
                            <button class="refresh-btn" onclick="refreshChocoPackage('${pkg.app_id}', this)">
                                <span class="refresh-icon">↻</span>
                            </button>
                            <button class="stop-btn" onclick="stopPackageOperation('choco', '${pkg.app_id}', this)" style="display: none;">
                                <span class="stop-icon">⬛</span>
                            </button>
                            <label class="toggle package-toggle">
                                <input type="checkbox" data-app-id="${pkg.app_id}">
                                <span class="slider"></span>
                            </label>
                        </div>
                    </div>
                    <div class="package-progress">
                        <div class="progress-container">
                            <div class="progress-bar">
                                <div class="progress-bar-fill"></div>
                            </div>
                            <div class="progress-text"></div>
                        </div>
                    </div>
                `;
                
                packageGrid.appendChild(card);
                
                const toggle = card.querySelector('input[type="checkbox"]');
                toggle.addEventListener('change', () => handleChocoPackageToggle(pkg.app_id, toggle));
            }

            // Check for cached status data
            const cachedStatus = sessionStorage.getItem('chocoPackageStatus');
            if (cachedStatus) {
                addLogEntry('Using cached Chocolatey package status data', 'INFO');
                updateChocoPackageStatusFromCache(JSON.parse(cachedStatus));
            } else {
                addLogEntry('Performing initial Chocolatey bulk status check...', 'INFO');
                await performInitialChocoBulkCheck();
            }
        }

        /**
         * Updates Chocolatey package status from cached data
         * @param {Object} statusData - Cached status data
         */
        function updateChocoPackageStatusFromCache(statusData) {
            addLogEntry('Updating Chocolatey package status from cache...', 'DEBUG');
            const packageCards = document.querySelectorAll('#choco-package-grid .package-card');
            
            packageCards.forEach(card => {
                const appId = card.querySelector('input[type="checkbox"]').dataset.appId;
                const status = statusData[appId];
                
                if (status) {
                    const statusBadge = card.querySelector('.status-badge');
                    const versionSpan = card.querySelector('.version');
                    const toggle = card.querySelector('input[type="checkbox"]');
                    
                    if (status.installed) {
                        statusBadge.textContent = 'Installed';
                        statusBadge.className = 'status-badge installed';
                        versionSpan.textContent = status.version || '';
                        toggle.checked = true;
                        addLogEntry(`Chocolatey package ${appId} is installed (version ${status.version || 'unknown'})`, 'SUCCESS');
                    } else {
                        statusBadge.textContent = 'Not Installed';
                        statusBadge.className = 'status-badge not-installed';
                        versionSpan.textContent = '';
                        toggle.checked = false;
                        addLogEntry(`Chocolatey package ${appId} is not installed`, 'INFO');
                    }
                }
            });
            addLogEntry('Chocolatey package status updated from cache', 'SUCCESS');
        }

        /**
         * Updated Chocolatey Bulk Status Check
         */
        async function performInitialChocoBulkCheck() {
            const packageCards = document.querySelectorAll('#choco-package-grid .package-card');
            const bulkProgressContainer = document.querySelector('#choco-status .bulk-progress');
            const bulkRefreshBtn = document.querySelector('#choco-status .bulk-refresh-btn');
            const statusCache = {};
            
            showProgress(bulkProgressContainer, 'Starting bulk check...');
            bulkRefreshBtn.disabled = true;
            
            try {
                const packageIds = Array.from(packageCards).map(card => 
                    card.querySelector('input[type="checkbox"]').dataset.appId
                );
                
                addLogEntry(`Checking status for ${packageIds.length} Chocolatey packages...`, 'INFO');
                
                let completedChecks = 0;
                const totalPackages = packageIds.length;
                
                // Create an array of promises for all package checks
                const checkPromises = packageIds.map(async appId => {
                    const card = Array.from(packageCards).find(card => 
                        card.querySelector('input[type="checkbox"]').dataset.appId === appId
                    );
                    
                    addLogEntry(`Checking status for Chocolatey package ${appId}...`, 'DEBUG');
                    
                    try {
                        const response = await fetch('http://localhost:9000/api/choco/bulk-package-status', {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({ appId, refresh: true })
                        });
                        
                        const data = await response.json();
                        statusCache[appId] = data.status;
                        
                        completedChecks++;
                        const progress = (completedChecks / totalPackages) * 100;
                        updateProgress(bulkProgressContainer, progress, `Checking packages (${completedChecks}/${totalPackages})...`);
                        
                        const statusBadge = card.querySelector('.status-badge');
                        const versionSpan = card.querySelector('.version');
                        const toggle = card.querySelector('input[type="checkbox"]');
                        
                        if (data.status && data.status.installed) {
                            statusBadge.textContent = 'Installed';
                            statusBadge.className = 'status-badge installed';
                            versionSpan.textContent = data.status.version || '';
                            toggle.checked = true;
                            addLogEntry(`Chocolatey package ${appId} is installed (version ${data.status.version || 'unknown'})`, 'SUCCESS');
                        } else {
                            statusBadge.textContent = 'Not Installed';
                            statusBadge.className = 'status-badge not-installed';
                            versionSpan.textContent = '';
                            toggle.checked = false;
                            addLogEntry(`Chocolatey package ${appId} is not installed`, 'INFO');
                        }
                        return { appId, success: true };
                    } catch (error) {
                        completedChecks++;
                        const progress = (completedChecks / totalPackages) * 100;
                        updateProgress(bulkProgressContainer, progress, `Checking packages (${completedChecks}/${totalPackages})...`);
                        
                        const statusBadge = card.querySelector('.status-badge');
                        statusBadge.textContent = 'Error';
                        statusBadge.className = 'status-badge not-installed';
                        addLogEntry(`Error checking Chocolatey package ${appId}: ${error.message}`, 'ERROR');
                        return { appId, success: false, error };
                    }
                });
                
                // Wait for all checks to complete
                const results = await Promise.allSettled(checkPromises);
                const failures = results.filter(r => r.status === 'rejected' || (r.status === 'fulfilled' && !r.value.success));
                
                // Update progress bar to completion
                updateProgress(bulkProgressContainer, 100, 'Status check complete');
                setTimeout(() => {
                    hideProgress(bulkProgressContainer);
                    bulkRefreshBtn.disabled = false;
                }, 1000);
                
                if (failures.length > 0) {
                    addLogEntry(`${failures.length} Chocolatey package checks failed`, 'WARNING');
                } else {
                    sessionStorage.setItem('chocoPackageStatus', JSON.stringify(statusCache));
                    addLogEntry('Initial Chocolatey bulk status check completed successfully', 'SUCCESS');
                }
                
            } catch (error) {
                addLogEntry(`Error during Chocolatey bulk status check: ${error.message}`, 'ERROR');
                
                updateProgress(bulkProgressContainer, 100, 'Error during bulk check');
                setTimeout(() => {
                    hideProgress(bulkProgressContainer);
                    bulkRefreshBtn.disabled = false;
                }, 2000);
                
                packageCards.forEach(card => {
                    const statusBadge = card.querySelector('.status-badge');
                    statusBadge.textContent = 'Error';
                    statusBadge.className = 'status-badge not-installed';
                });
            }
        }

        /**
         * Updated Chocolatey Package Toggle Handler
         */
        async function handleChocoPackageToggle(appId, toggle) {
            const card = toggle.closest('.package-card');
            const statusBadge = card.querySelector('.status-badge');
            const versionSpan = card.querySelector('.version');
            const stopBtn = card.querySelector('.stop-btn');
            const progressContainer = card.querySelector('.package-progress');
            const action = toggle.checked ? 'install' : 'uninstall';
            const originalState = !toggle.checked;
            
            addLogEntry(`Starting ${action} for Chocolatey package ${appId}...`, 'INFO');
            statusBadge.textContent = toggle.checked ? 'Queued for Install...' : 'Queued for Uninstall...';
            toggle.disabled = true;
            stopBtn.style.display = 'flex';
            showProgress(progressContainer, `Queued for ${action}...`);
            
            const operation = async () => {
                try {
                    statusBadge.textContent = toggle.checked ? 'Installing...' : 'Uninstalling...';
                    updateProgress(progressContainer, 10, `Starting ${action}...`);
                    
                    const response = await fetch(`http://localhost:9000/api/choco/${action}-package`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ appId })
                    });

                    const responseData = await response.json();
                    if (!responseData.success && responseData.error) {
                        throw new Error(responseData.error);
                    }

                    let attempts = 0;
                    let isComplete = false;

                    while (!isComplete && attempts < CONFIG.MAX_RETRIES) {
                        await new Promise(resolve => setTimeout(resolve, CONFIG.POLL_INTERVAL));
                        
                        const progress = Math.min(90, 10 + (attempts * (80 / CONFIG.MAX_RETRIES)));
                        updateProgress(progressContainer, progress, `${action === 'install' ? 'Installing' : 'Uninstalling'}...`);
                        
                        addLogEntry(`Checking ${action} status for Chocolatey package ${appId} (attempt ${attempts + 1})...`, 'DEBUG');
                        
                        const statusResponse = await fetch('http://localhost:9000/api/choco/single-package-status', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ appId, refresh: true })
                        });
                        
                        const data = await statusResponse.json();
                        
                        if (data.status && data.status.error) {
                            statusBadge.textContent = 'Error';
                            statusBadge.className = 'status-badge error';
                            toggle.checked = originalState;
                            toggle.disabled = true;
                            updateProgress(progressContainer, 100, 'Error!');
                            addLogEntry(`Error during Chocolatey package ${action}: ${data.status.error}`, 'ERROR');
                            throw new Error(data.status.error);
                        }
                        
                        if (data.status) {
                            const isActuallyInstalled = data.status.version !== null;
                            
                            if (isActuallyInstalled === toggle.checked) {
                                isComplete = true;
                                stopBtn.style.display = 'none';
                                toggle.disabled = false;
                                
                                updateProgress(progressContainer, 100, 'Complete!');
                                
                                if (isActuallyInstalled) {
                                    statusBadge.textContent = 'Installed';
                                    statusBadge.className = 'status-badge installed';
                                    versionSpan.textContent = data.status.version || '';
                                    toggle.checked = true;
                                    addLogEntry(`Successfully installed Chocolatey package ${appId} (version ${data.status.version || 'unknown'})`, 'SUCCESS');
                                } else {
                                    statusBadge.textContent = 'Not Installed';
                                    statusBadge.className = 'status-badge not-installed';
                                    versionSpan.textContent = '';
                                    toggle.checked = false;
                                    addLogEntry(`Successfully uninstalled Chocolatey package ${appId}`, 'SUCCESS');
                                }
                                
                                setTimeout(() => {
                                    hideProgress(progressContainer);
                                }, 1000);
                                
                                return;
                            }
                        }
                        
                        attempts++;
                    }
                    
                } catch (error) {
                    statusBadge.textContent = 'Error';
                    statusBadge.className = 'status-badge error';
                    toggle.checked = originalState;
                    updateProgress(progressContainer, 100, 'Error!');
                    addLogEntry(`Error during Chocolatey package ${action}: ${error.message}`, 'ERROR');
                    
                    setTimeout(() => {
                        hideProgress(progressContainer);
                    }, 2000);
                    
                    throw error;
                } finally {
                    toggle.disabled = !isComplete;
                    stopBtn.style.display = 'none';
                }
            };

            // Add operation to queue
            try {
                await operationQueue.addOperation('choco', appId, operation);
            } catch (error) {
                statusBadge.textContent = 'Error';
                statusBadge.className = 'status-badge error';
                toggle.checked = originalState;
                toggle.disabled = true;
                stopBtn.style.display = 'none';
                updateProgress(progressContainer, 100, 'Error!');
                addLogEntry(`Operation failed: ${error.message}`, 'ERROR');
                
                setTimeout(() => {
                    hideProgress(progressContainer);
                }, 2000);
            }
        }

        /**
         * Refreshes the status of a single Chocolatey package
         * @param {string} appId - The package identifier
         * @param {HTMLElement} button - The refresh button element
         */
        async function refreshChocoPackage(appId, button) {
            const card = button.closest('.package-card');
            const statusBadge = card.querySelector('.status-badge');
            const refreshIcon = button.querySelector('.refresh-icon');
            
            addLogEntry(`Refreshing status for Chocolatey package ${appId}...`, 'INFO');
            button.disabled = true;
            statusBadge.textContent = 'Checking...';
            refreshIcon.style.transform = 'rotate(360deg)';
            
            try {
                const response = await fetch('http://localhost:9000/api/choco/single-package-status', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ appId, refresh: true })
                });
                
                const data = await response.json();
                const versionSpan = card.querySelector('.version');
                const toggle = card.querySelector('input[type="checkbox"]');
                
                if (data.status && data.status.installed) {
                    statusBadge.textContent = 'Installed';
                    statusBadge.className = 'status-badge installed';
                    versionSpan.textContent = data.status.version || '';
                    toggle.checked = true;
                    addLogEntry(`Chocolatey package ${appId} is installed (version ${data.status.version || 'unknown'})`, 'SUCCESS');
                } else {
                    statusBadge.textContent = 'Not Installed';
                    statusBadge.className = 'status-badge not-installed';
                    versionSpan.textContent = '';
                    toggle.checked = false;
                    addLogEntry(`Chocolatey package ${appId} is not installed`, 'INFO');
                }
            } catch (error) {
                statusBadge.textContent = 'Error';
                statusBadge.className = 'status-badge not-installed';
                addLogEntry(`Error refreshing Chocolatey package status for ${appId}: ${error.message}`, 'ERROR');
            } finally {
                button.disabled = false;
                refreshIcon.style.transform = 'rotate(0deg)';
            }
        }

        /**
         * Forces a bulk status check for all Chocolatey packages
         */
        async function forceChocoBulkStatusCheck() {
            const bulkRefreshBtn = document.querySelector('#choco-status .bulk-refresh-btn');
            const packageCards = document.querySelectorAll('#choco-package-grid .package-card');
            
            addLogEntry('Starting forced Chocolatey bulk status check...', 'INFO');
            bulkRefreshBtn.disabled = true;
            
            try {
                packageCards.forEach(card => {
                    const statusBadge = card.querySelector('.status-badge');
                    statusBadge.textContent = 'Checking...';
                });
                
                await performInitialChocoBulkCheck();
                addLogEntry('Forced Chocolatey bulk status check completed successfully', 'SUCCESS');
            } catch (error) {
                addLogEntry(`Error during forced Chocolatey bulk status check: ${error.message}`, 'ERROR');
                
                packageCards.forEach(card => {
                    const statusBadge = card.querySelector('.status-badge');
                    statusBadge.textContent = 'Error';
                    statusBadge.className = 'status-badge not-installed';
                });
            } finally {
                bulkRefreshBtn.disabled = false;
            }
        }

        /**
         * Retries a failed API call with exponential backoff
         */
        async function retryWithBackoff(fn, retries = 3, backoff = 300) {
            try {
                return await fn();
            } catch (error) {
                if (retries === 0) throw error;
                
                await new Promise(resolve => setTimeout(resolve, backoff));
                return retryWithBackoff(fn, retries - 1, backoff * 2);
            }
        }

        /**
         * Makes an API call with timeout and retry support
         */
        async function makeApiCall(url, options = {}, timeout = 5000) {
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), timeout);
            
            try {
                const response = await retryWithBackoff(async () => {
                    try {
                        const res = await fetch(url, {
                            ...options,
                            signal: controller.signal
                        });
                        
                        if (!res.ok) {
                            throw new Error(`HTTP error! status: ${res.status}`);
                        }
                        
                        return res;
                    } catch (error) {
                        if (error.name === 'AbortError') {
                            throw new Error('Request timed out');
                        }
                        throw error;
                    }
                });
                
                return await response.json();
            } finally {
                clearTimeout(timeoutId);
            }
        }
    </script>
</body>
</html> 
